package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/debug"
	"strings"
	"sync"
	"syscall"
	"time"

	"backend/internal/plc"
	"backend/internal/radar"
)

var (
	// Loggers especializados
	systemLogger   *log.Logger
	errorLogger    *log.Logger
	radarLogger    *log.Logger
	plcLogger      *log.Logger
	networkLogger  *log.Logger
	criticalLogger *log.Logger

	// Arquivos de log
	systemLogFile   *os.File
	errorLogFile    *os.File
	radarLogFile    *os.File
	plcLogFile      *os.File
	networkLogFile  *os.File
	criticalLogFile *os.File

	// ‚úÖ CORRE√á√ÉO 1: Estados anteriores COM PROTE√á√ÉO THREAD-SAFE
	lastRadarStates map[string]bool
	lastPLCState    bool
	stateMutex      sync.RWMutex // NOVO: Prote√ß√£o contra race conditions

	// ‚úÖ CORRE√á√ÉO 2: Context global para controle de goroutines
	globalCtx    context.Context
	globalCancel context.CancelFunc
	mainWg       sync.WaitGroup

	// ‚úÖ CORRE√á√ÉO 3: Canal para shutdown gracioso
	shutdownChan chan struct{}
)

// Configura√ß√£o de log rotation
const (
	MAX_LOG_FILES = 7  // Manter apenas 7 dias de logs
	MAX_LOG_SIZE  = 10 // 10MB por arquivo (rotacionar se passar)
)

// ‚úÖ Estrutura para m√©tricas do sistema - COM PROTE√á√ÉO THREAD-SAFE
type SystemMetrics struct {
	mutex              sync.RWMutex // NOVO: Prote√ß√£o thread-safe
	StartTime          time.Time
	PLCConnections     int64
	PLCDisconnections  int64
	RadarReconnections map[string]int64
	TotalPackets       int64
	TotalErrors        int64
	NetworkErrors      int64
	LastUpdate         time.Time
}

// ‚úÖ M√âTODOS THREAD-SAFE PARA METRICS
func (m *SystemMetrics) IncrementPLCConnections() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.PLCConnections++
}

func (m *SystemMetrics) IncrementPLCDisconnections() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.PLCDisconnections++
}

func (m *SystemMetrics) IncrementTotalPackets() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.TotalPackets++
}

func (m *SystemMetrics) IncrementNetworkErrors() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.NetworkErrors++
}

func (m *SystemMetrics) IncrementTotalErrors() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.TotalErrors++
}

func (m *SystemMetrics) GetStats() (int64, int64, int64, int64, int64) {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return m.PLCConnections, m.PLCDisconnections, m.TotalPackets, m.NetworkErrors, m.TotalErrors
}

func (m *SystemMetrics) UpdateLastUpdate() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.LastUpdate = time.Now()
}

var metrics *SystemMetrics

func main() {
	// ‚úÖ CORRE√á√ÉO 4: Context para controle global
	globalCtx, globalCancel = context.WithCancel(context.Background())
	shutdownChan = make(chan struct{})

	// PANIC RECOVERY
	defer func() {
		if r := recover(); r != nil {
			timestamp := time.Now().Format("2006-01-02 15:04:05")

			if criticalLogger != nil {
				criticalLogger.Printf("üî• CRASH CR√çTICO: %s - %v", timestamp, r)
				criticalLogger.Printf("Stack Trace: %s", string(debug.Stack()))
			}

			fmt.Printf("\nüî• CRASH DETECTADO: %s - Erro: %v\n", timestamp, r)
			gracefulShutdown()
			os.Exit(1)
		}
	}()

	setupGracefulShutdown()

	// APLICAR LOG ROTATION ANTES DE INICIALIZAR
	cleanupOldLogs()

	// Inicializar logs usando SUA estrutura de pastas
	initLogsInYourStructure()
	defer closeAllLogs()

	// ‚úÖ Iniciar worker de log rotation com context
	mainWg.Add(1)
	go logRotationWorker()

	initMetrics()
	initStates()
	printSystemHeader()

	// LOG INICIAL APENAS
	systemLogger.Println("========== SISTEMA RADAR SICK v3.1 THREAD-SAFE INICIADO ==========")
	systemLogger.Printf("Usu√°rio: %s | Data: %s | Vers√£o: v3.1.0",
		getCurrentUser(), time.Now().Format("2006-01-02 15:04:05"))
	systemLogger.Printf("CORRE√á√ïES: Race conditions ‚úÖ Memory leaks ‚úÖ Deadlocks ‚úÖ")

	// Criar gerenciador de radares
	radarManager := radar.NewRadarManager()
	addRadarsToManager(radarManager)

	// Vari√°veis de controle PLC
	var plcSiemens *plc.SiemensPLC
	var plcController *plc.PLCController
	plcConnected := false
	lastPLCAttempt := time.Time{}
	consecutivePLCErrors := 0

	// ‚úÖ FUN√á√ÉO DE RECONEX√ÉO PLC OTIMIZADA COM CONTEXT
	tryReconnectPLC := func() bool {
		select {
		case <-globalCtx.Done():
			return false
		default:
		}

		now := time.Now()

		if plcConnected && plcSiemens != nil && plcSiemens.IsConnected() {
			return true
		}

		if now.Sub(lastPLCAttempt) < 12*time.Second {
			return false
		}

		lastPLCAttempt = now

		// Cleanup
		if plcController != nil {
			plcController.Stop()
			time.Sleep(300 * time.Millisecond)
			plcController = nil
		}
		if plcSiemens != nil && plcSiemens.IsConnected() {
			plcSiemens.Disconnect()
			metrics.IncrementPLCDisconnections()
		}

		// Nova conex√£o
		plcSiemens = plc.NewSiemensPLC("192.168.1.33")
		err := plcSiemens.Connect()
		if err != nil {
			consecutivePLCErrors++

			// LOG S√ì QUANDO MUDA DE ESTADO OU ERRO CR√çTICO
			if consecutivePLCErrors == 1 {
				errorLogger.Printf("PLC_CONNECTION_LOST: 192.168.1.33 - %v", err)
				networkLogger.Printf("NETWORK_FAILURE: PLC unreachable - %v", err)

				// An√°lise espec√≠fica s√≥ em caso cr√≠tico
				if strings.Contains(err.Error(), "no route to host") {
					networkLogger.Printf("NETWORK_DIAGNOSIS: Sem rota para PLC - verificar switch/cabo")
				} else if strings.Contains(err.Error(), "connection refused") {
					networkLogger.Printf("NETWORK_DIAGNOSIS: PLC offline ou firewall bloqueando")
				}
			}

			metrics.IncrementNetworkErrors()
			plcConnected = false

			// ‚úÖ THREAD-SAFE UPDATE
			stateMutex.Lock()
			lastPLCState = false
			stateMutex.Unlock()

			return false
		}

		if !plcSiemens.IsConnected() {
			consecutivePLCErrors++
			plcConnected = false
			return false
		}

		// ‚úÖ PLC CONTROLLER v3.1 COM CONTEXT
		plcController = plc.NewPLCController(plcSiemens.Client)

		// ‚úÖ GOROUTINE COM WAITGROUP E CONTEXT
		mainWg.Add(1)
		go func() {
			defer mainWg.Done()
			defer func() {
				if r := recover(); r != nil {
					criticalLogger.Printf("üî• PLC_CONTROLLER_PANIC: %v", r)
					criticalLogger.Printf("PLC_STACK: %s", string(debug.Stack()))
					errorLogger.Printf("PLC_GOROUTINE_CRASH: PLCController falhou - %v", r)
					plcConnected = false
				}
			}()

			// ‚úÖ PASSAR CONTEXT PARA PLC CONTROLLER
			plcController.StartWithContext(globalCtx)
		}()

		time.Sleep(1500 * time.Millisecond)

		consecutivePLCErrors = 0
		plcConnected = true
		metrics.IncrementPLCConnections()

		// ‚úÖ THREAD-SAFE UPDATE
		stateMutex.Lock()
		wasLastPLCState := lastPLCState
		lastPLCState = true
		stateMutex.Unlock()

		// LOG S√ì QUANDO RECONECTA AP√ìS FALHA
		if !wasLastPLCState {
			plcLogger.Printf("PLC_RECONNECTED: Conectado ap√≥s %d tentativas", consecutivePLCErrors)
			systemLogger.Printf("PLC_RECOVERY: Sistema PLC v3.1 restaurado")
		}

		return true
	}

	// Primeira conex√£o
	tryReconnectPLC()
	time.Sleep(2 * time.Second)

	enabledRadars := getInitialRadarStates(plcConnected, plcController)
	connectEnabledRadars(radarManager, enabledRadars)

	systemLogger.Println("SYSTEM_READY: Loop principal v3.1 iniciado - THREAD-SAFE")

	// ‚úÖ LOOP PRINCIPAL v3.1 - COMPLETAMENTE THREAD-SAFE
	lastReconnectCheck := time.Now()
	lastMetricsUpdate := time.Now()
	lastRadarMonitor := time.Now()

	// ‚úÖ Ticker com context
	mainTicker := time.NewTicker(200 * time.Millisecond)
	defer mainTicker.Stop()

	for {
		select {
		case <-globalCtx.Done():
			fmt.Println("üõë Sistema recebeu sinal de parada - finalizando loop principal")
			return

		case <-shutdownChan:
			fmt.Println("üõë Shutdown solicitado - finalizando loop principal")
			return

		case <-mainTicker.C:
			metrics.UpdateLastUpdate()

			// PLC
			plcConnected = tryReconnectPLC()

			// Estados
			collectionActive := true
			var currentEnabledRadars map[string]bool

			if plcConnected && plcController != nil {
				collectionActive = plcController.IsCollectionActive()
				currentEnabledRadars = plcController.GetRadarsEnabled()

				// LOG S√ì EMERGENCY STOP (CR√çTICO)
				if plcController.IsEmergencyStop() {
					criticalLogger.Println("üö® EMERGENCY_STOP: Parada de emerg√™ncia ativada via PLC")
					errorLogger.Println("SYSTEM_HALT: Sistema pausado por emerg√™ncia")
					time.Sleep(3 * time.Second)
					continue
				}

				// ‚úÖ RECONEX√ÉO ASS√çNCRONA v3.1 - COM CONTEXT E WAITGROUP
				if time.Since(lastReconnectCheck) >= 15*time.Second {
					mainWg.Add(1)
					go func(radars map[string]bool) {
						defer mainWg.Done()

						// ‚úÖ Context com timeout para evitar goroutine leak
						ctx, cancel := context.WithTimeout(globalCtx, 30*time.Second)
						defer cancel()

						radarManager.CheckAndReconnectEnabledAsyncWithContext(ctx, radars)
					}(currentEnabledRadars)
					lastReconnectCheck = time.Now()
				}

				// ‚úÖ MONITORAMENTO INTELIGENTE DE TIMEOUT COM CONTEXT
				if time.Since(lastRadarMonitor) >= 10*time.Second {
					mainWg.Add(1)
					go func(controller *plc.PLCController) {
						defer mainWg.Done()

						select {
						case <-globalCtx.Done():
							return
						default:
						}

						// Verificar radares pr√≥ximos do timeout
						radars := []string{"caldeira", "porta_jusante", "porta_montante"}
						for _, radarID := range radars {
							isTimingOut, duration := controller.IsRadarTimingOut(radarID)
							if isTimingOut {
								fmt.Printf("‚ö†Ô∏è AVISO: Radar %s pr√≥ximo do timeout (%.1fs/45s)\n",
									radarID, duration.Seconds())
								radarLogger.Printf("TIMEOUT_WARNING: %s approaching timeout after %.1fs",
									radarID, duration.Seconds())
							}
						}
					}(plcController)
					lastRadarMonitor = time.Now()
				}

			} else {
				currentEnabledRadars = map[string]bool{
					"caldeira":       false,
					"porta_jusante":  false,
					"porta_montante": false,
				}
			}

			if !collectionActive {
				time.Sleep(1 * time.Second)
				continue
			}

			// ‚úÖ COLETA ASS√çNCRONA v3.1 - COM CONTEXT
			ctx, cancel := context.WithTimeout(globalCtx, 500*time.Millisecond)
			multiRadarData := radarManager.CollectEnabledRadarsDataAsyncWithContext(ctx, currentEnabledRadars)
			cancel()

			metrics.IncrementTotalPackets()

			// PLC Update
			if plcConnected && plcController != nil {
				connectionStatus := radarManager.GetConnectionStatus()
				err := plcController.WriteMultiRadarData(multiRadarData)
				if err != nil {
					if isConnectionError(err) {
						// LOG S√ì QUANDO PERDE CONEX√ÉO
						plcLogger.Printf("PLC_WRITE_FAILURE: Conex√£o perdida durante escrita")
						errorLogger.Printf("PLC_COMMUNICATION_ERROR: %v", err)
						networkLogger.Printf("CONNECTION_INTERRUPTED: Durante opera√ß√£o PLC")
						plcConnected = false
						metrics.IncrementPLCDisconnections()
						metrics.IncrementNetworkErrors()
					} else {
						// LOG ERROS DE ESCRITA
						errorLogger.Printf("PLC_DB_WRITE_ERROR: Falha ao escrever DB100 - %v", err)
						metrics.IncrementTotalErrors()
					}
				}
				plcController.SetRadarsConnected(connectionStatus)
			}

			// LOG INTELIGENTE DE RADARES - S√ì MUDAN√áAS DE ESTADO
			if time.Since(lastMetricsUpdate) >= 5*time.Second {
				displaySystemStatusV3(plcConnected, currentEnabledRadars, radarManager, plcController)

				// ‚úÖ THREAD-SAFE LOG
				logRadarStateChangesThreadSafe(radarManager, currentEnabledRadars)

				flushAllLogs()
				lastMetricsUpdate = time.Now()
			}
		}
	}
}

// ‚úÖ NOVA FUN√á√ÉO: gracefulShutdown - SHUTDOWN LIMPO
func gracefulShutdown() {
	fmt.Println("\nüõë Iniciando shutdown gracioso...")

	// Cancelar context global
	if globalCancel != nil {
		globalCancel()
	}

	// Fechar canal de shutdown
	select {
	case shutdownChan <- struct{}{}:
	default:
	}

	// Aguardar goroutines com timeout
	done := make(chan struct{})
	go func() {
		mainWg.Wait()
		close(done)
	}()

	select {
	case <-done:
		fmt.Println("‚úÖ Todas as goroutines finalizadas")
	case <-time.After(10 * time.Second):
		fmt.Println("‚ö†Ô∏è Timeout no shutdown - for√ßando parada")
	}

	closeAllLogs()
}

// ‚úÖ FUN√á√ÉO THREAD-SAFE: logRadarStateChangesThreadSafe
func logRadarStateChangesThreadSafe(radarManager *radar.RadarManager, currentEnabledRadars map[string]bool) {
	connectionStatus := radarManager.GetConnectionStatus()

	// ‚úÖ PROTE√á√ÉO THREAD-SAFE
	stateMutex.Lock()
	defer stateMutex.Unlock()

	for radarID, enabled := range currentEnabledRadars {
		config, _ := radarManager.GetRadarConfig(radarID)

		// Estado atual
		currentState := enabled && connectionStatus[radarID]

		// Estado anterior
		lastState, exists := lastRadarStates[radarID]

		// LOG S√ì SE MUDOU O ESTADO
		if !exists || lastState != currentState {
			if enabled {
				if connectionStatus[radarID] {
					if !exists || !lastState {
						radarLogger.Printf("RADAR_ONLINE: %s (%s) conectado", config.Name, config.IP)
					}
				} else {
					if !exists || lastState {
						radarLogger.Printf("RADAR_OFFLINE: %s (%s) perdeu conex√£o", config.Name, config.IP)
						errorLogger.Printf("RADAR_CONNECTION_LOST: %s - verificar rede", config.Name)
						networkLogger.Printf("RADAR_UNREACHABLE: %s %s:2111", config.Name, config.IP)

						// ‚úÖ VERS√ÉO OTIMIZADA COM SWITCH:
						switch config.IP {
						case "192.168.1.84":
							// l√≥gica para caldeira
						case "192.168.1.85":
							// l√≥gica para porta jusante
						case "192.168.1.86":
							// l√≥gica para porta montante
						default:
							// caso padr√£o
						}
					}
				}
			}

			// Atualizar estado anterior
			lastRadarStates[radarID] = currentState
		}
	}
}

// üîÑ LOG ROTATION WORKER - COM CONTEXT
func logRotationWorker() {
	defer mainWg.Done()

	ticker := time.NewTicker(1 * time.Hour)
	defer ticker.Stop()

	for {
		select {
		case <-globalCtx.Done():
			fmt.Println("üîÑ Log rotation worker finalizado")
			return

		case <-ticker.C:
			// Verificar tamanho dos arquivos atuais
			checkLogFileSizes()

			// Limpar logs antigos
			cleanupOldLogs()

			// Log da manuten√ß√£o
			if systemLogger != nil {
				systemLogger.Printf("LOG_ROTATION: Manuten√ß√£o autom√°tica executada")
			}
		}
	}
}

// ‚úÖ NOVA FUN√á√ÉO: displaySystemStatusV3 - COM TIMEOUT INTELIGENTE
func displaySystemStatusV3(plcConnected bool, enabledRadars map[string]bool, radarManager *radar.RadarManager, plcController *plc.PLCController) {
	fmt.Print("\033[13H\033[J")

	plcStatus := "üî¥ DESCONECTADO"
	if plcConnected {
		plcStatus = "üü¢ CONECTADO"
	}

	connectionStatus := radarManager.GetConnectionStatus()
	connectedCount := 0
	enabledCount := 0

	fmt.Printf("üéõÔ∏è  PLC Siemens v3.1 THREAD-SAFE: %s\n", plcStatus)
	fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")

	radarConfigs := []struct{ id, name string }{
		{"caldeira", "Radar Caldeira"},
		{"porta_jusante", "Radar Porta Jusante"},
		{"porta_montante", "Radar Porta Montante"},
	}

	for _, config := range radarConfigs {
		isEnabled := enabledRadars[config.id]
		isConnected := connectionStatus[config.id]

		if isEnabled {
			enabledCount++
		}
		if isConnected && isEnabled {
			connectedCount++
		}

		status := "üî¥ DESCONECTADO"
		extraInfo := ""

		if !isEnabled {
			status = "‚ö´ DESABILITADO"
		} else if isConnected {
			status = "üü¢ CONECTADO   "
			// ‚úÖ MOSTRAR TEMPO SEM DADOS
			if plcController != nil {
				lastUpdate := plcController.GetRadarLastUpdate(config.id)
				if !lastUpdate.IsZero() {
					timeSinceUpdate := time.Since(lastUpdate)
					if timeSinceUpdate < 5*time.Second {
						extraInfo = fmt.Sprintf("(%.1fs)", timeSinceUpdate.Seconds())
					} else if timeSinceUpdate < 30*time.Second {
						extraInfo = fmt.Sprintf("(‚ö†Ô∏è%.1fs)", timeSinceUpdate.Seconds())
					} else {
						extraInfo = fmt.Sprintf("(üö®%.1fs)", timeSinceUpdate.Seconds())
					}
				}
			}
		} else {
			// ‚úÖ VERIFICAR SE EST√Å EM RECONEX√ÉO
			if plcController != nil && plcController.IsAnyRadarReconnecting() {
				reconnecting := plcController.GetReconnectingRadars()
				for _, reconId := range reconnecting {
					if reconId == config.id {
						status = "üîÑ RECONECTANDO"
						break
					}
				}
			}
		}

		fmt.Printf("‚îÇ %-20s %s %-12s            ‚îÇ\n", config.name+":", status, extraInfo)
	}

	fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
	fmt.Printf("üìä Resumo: %d/%d habilitados | %d conectados", enabledCount, 3, connectedCount)

	// ‚úÖ MOSTRAR TIMEOUT ATUAL
	if plcController != nil {
		timeout := plcController.GetRadarTimeoutDuration()
		fmt.Printf(" | Timeout: %v\n", timeout)
	} else {
		fmt.Printf("\n")
	}

	uptime := time.Since(metrics.StartTime)
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	memMB := float64(m.Alloc) / (1024 * 1024)

	// ‚úÖ THREAD-SAFE METRICS ACCESS
	plcConn, plcDisconn, totalPackets, networkErr, totalErrors := metrics.GetStats()

	fmt.Println()
	fmt.Println("üìà M√âTRICAS v3.1 THREAD-SAFE:")
	fmt.Printf("   ‚è±Ô∏è  Uptime: %s\n", formatDuration(uptime))
	fmt.Printf("   üîå PLC: %d conex√µes (%d desconex√µes)\n", plcConn, plcDisconn)
	fmt.Printf("   üì¶ Pacotes: %d\n", totalPackets)
	fmt.Printf("   ‚ùå Erros: %d (Rede: %d)\n", totalErrors, networkErr)
	fmt.Printf("   üíæ Mem√≥ria: %.1fMB\n", memMB)

	// ‚úÖ ESTAT√çSTICAS DETALHADAS DO PLC
	if plcController != nil {
		stats := plcController.GetSystemStatistics()
		if radarsStats, ok := stats["radars"].(map[string]interface{}); ok {
			fmt.Println()
			fmt.Println("üì° DETALHES DOS RADARES:")
			for radarID, radarInfo := range radarsStats {
				if info, ok := radarInfo.(map[string]interface{}); ok {
					fmt.Printf("   %s: P=%v E=%v Update=%s\n",
						radarID,
						info["packets"],
						info["errors"],
						info["last_update"])
				}
			}
		}
	}

	fmt.Println()
	fmt.Printf("üöÄ SISTEMA v3.1: THREAD-SAFE + Timeout Inteligente (45s)\n")
	fmt.Printf("‚úÖ SEM RACE CONDITIONS: Acesso protegido com mutex\n")
	fmt.Printf("‚úÖ SEM MEMORY LEAKS: Limpeza autom√°tica de maps\n")
	fmt.Printf("‚úÖ SEM DEADLOCKS: Locks hier√°rquicos\n")
	fmt.Printf("‚ö° RESPONSIVO: Coleta em 200ms + Timeout em 500ms\n")
	fmt.Println("üö® Sistema focado em FALHAS e ALARMES... Ctrl+C para parar.")
}

// üßπ LIMPEZA DE LOGS ANTIGOS
func cleanupOldLogs() {
	logFolders := []string{
		"backend/logs/system",
		"backend/logs/radar",
		"backend/logs/plc",
		"backend/logs/critical",
		"backend/logs/error",
		"backend/logs/network",
	}

	cutoffDate := time.Now().AddDate(0, 0, -MAX_LOG_FILES)

	for _, folder := range logFolders {
		files, err := filepath.Glob(filepath.Join(folder, "*.log"))
		if err != nil {
			continue
		}

		for _, file := range files {
			fileInfo, err := os.Stat(file)
			if err != nil {
				continue
			}

			// Se arquivo √© mais antigo que MAX_LOG_FILES dias, deletar
			if fileInfo.ModTime().Before(cutoffDate) {
				os.Remove(file)
				fmt.Printf("üóëÔ∏è  Log antigo removido: %s\n", file)
			}
		}
	}

	// Mover logs antigos para archive se necess√°rio
	moveOldLogsToArchive()
}

// üì¶ MOVER LOGS ANTIGOS PARA ARCHIVE
func moveOldLogsToArchive() {
	archiveDir := "backend/logs/archive"
	if _, err := os.Stat(archiveDir); os.IsNotExist(err) {
		os.MkdirAll(archiveDir, 0755)
	}

	logFolders := []string{
		"backend/logs/system",
		"backend/logs/radar",
		"backend/logs/plc",
		"backend/logs/critical",
		"backend/logs/error",
		"backend/logs/network",
	}

	cutoffDate := time.Now().AddDate(0, 0, -3) // Mover logs de mais de 3 dias

	for _, folder := range logFolders {
		files, err := filepath.Glob(filepath.Join(folder, "*.log"))
		if err != nil {
			continue
		}

		for _, file := range files {
			fileInfo, err := os.Stat(file)
			if err != nil {
				continue
			}

			// Se arquivo tem mais de 3 dias, mover para archive
			if fileInfo.ModTime().Before(cutoffDate) {
				fileName := filepath.Base(file)
				archivePath := filepath.Join(archiveDir, fileName)

				// S√≥ move se n√£o existir no archive
				if _, err := os.Stat(archivePath); os.IsNotExist(err) {
					os.Rename(file, archivePath)
				}
			}
		}
	}
}

// üìè VERIFICAR TAMANHO DOS ARQUIVOS ATUAIS
func checkLogFileSizes() {
	logFiles := []*os.File{
		systemLogFile,
		errorLogFile,
		radarLogFile,
		plcLogFile,
		networkLogFile,
		criticalLogFile,
	}

	for _, file := range logFiles {
		if file == nil {
			continue
		}

		fileInfo, err := file.Stat()
		if err != nil {
			continue
		}

		// Se arquivo > MAX_LOG_SIZE MB, rotacionar
		sizeMB := fileInfo.Size() / (1024 * 1024)
		if sizeMB > MAX_LOG_SIZE {
			rotateLogFile(file)
		}
	}
}

// üîÑ ROTACIONAR ARQUIVO ESPEC√çFICO
func rotateLogFile(file *os.File) {
	if file == nil {
		return
	}

	fileName := file.Name()

	// Fechar arquivo atual
	file.Close()

	// Criar nome com timestamp
	timestamp := time.Now().Format("2006-01-02_15-04-05")
	rotatedName := strings.Replace(fileName, ".log", fmt.Sprintf("_%s.log", timestamp), 1)

	// Renomear arquivo atual
	os.Rename(fileName, rotatedName)

	// Recriar arquivo
	newFile, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		return
	}

	// Atualizar logger correspondente
	updateLoggerFile(fileName, newFile)

	fmt.Printf("üîÑ Log rotacionado: %s -> %s\n", fileName, rotatedName)
}

// üîÑ ATUALIZAR LOGGER AP√ìS ROTA√á√ÉO
func updateLoggerFile(fileName string, newFile *os.File) {
	if strings.Contains(fileName, "system") {
		systemLogFile = newFile
		systemLogger = log.New(systemLogFile, "[SYSTEM] ", log.LstdFlags|log.Lmicroseconds)
	} else if strings.Contains(fileName, "error") {
		errorLogFile = newFile
		errorLogger = log.New(errorLogFile, "[ERROR] ", log.LstdFlags|log.Lmicroseconds)
	} else if strings.Contains(fileName, "radar") {
		radarLogFile = newFile
		radarLogger = log.New(radarLogFile, "[RADAR] ", log.LstdFlags|log.Lmicroseconds)
	} else if strings.Contains(fileName, "plc") {
		plcLogFile = newFile
		plcLogger = log.New(plcLogFile, "[PLC] ", log.LstdFlags|log.Lmicroseconds)
	} else if strings.Contains(fileName, "network") {
		networkLogFile = newFile
		networkLogger = log.New(networkLogFile, "[NETWORK] ", log.LstdFlags|log.Lmicroseconds)
	} else if strings.Contains(fileName, "critical") {
		criticalLogFile = newFile
		criticalLogger = log.New(criticalLogFile, "[CRITICAL] ", log.LstdFlags|log.Lmicroseconds)
	}
}

// Inicializar estados anteriores - THREAD-SAFE
func initStates() {
	stateMutex.Lock()
	defer stateMutex.Unlock()

	lastRadarStates = make(map[string]bool)
	lastPLCState = false
}

// Inicializar m√©tricas - THREAD-SAFE
func initMetrics() {
	metrics = &SystemMetrics{
		StartTime:          time.Now(),
		PLCConnections:     0,
		PLCDisconnections:  0,
		RadarReconnections: make(map[string]int64),
		TotalPackets:       0,
		TotalErrors:        0,
		NetworkErrors:      0,
		LastUpdate:         time.Now(),
	}

	metrics.RadarReconnections["caldeira"] = 0
	metrics.RadarReconnections["porta_jusante"] = 0
	metrics.RadarReconnections["porta_montante"] = 0
}

// Inicializar logs usando SUA estrutura de pastas
func initLogsInYourStructure() {
	dateStr := time.Now().Format("2006-01-02")

	// Verificar se as pastas existem, se n√£o, criar
	folders := []string{
		"backend/logs/system",
		"backend/logs/radar",
		"backend/logs/plc",
		"backend/logs/critical",
		"backend/logs/error",
		"backend/logs/network",
		"backend/logs/archive",
	}

	for _, folder := range folders {
		if _, err := os.Stat(folder); os.IsNotExist(err) {
			os.MkdirAll(folder, 0755)
		}
	}

	var err error

	// SYSTEM LOG
	systemLogFile, err = os.OpenFile(fmt.Sprintf("backend/logs/system/system_%s.log", dateStr),
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Erro system log: %v", err)
	}
	systemLogger = log.New(systemLogFile, "[SYSTEM] ", log.LstdFlags|log.Lmicroseconds)

	// RADAR LOG
	radarLogFile, err = os.OpenFile(fmt.Sprintf("backend/logs/radar/radar_%s.log", dateStr),
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Erro radar log: %v", err)
	}
	radarLogger = log.New(radarLogFile, "[RADAR] ", log.LstdFlags|log.Lmicroseconds)

	// PLC LOG
	plcLogFile, err = os.OpenFile(fmt.Sprintf("backend/logs/plc/plc_%s.log", dateStr),
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Erro plc log: %v", err)
	}
	plcLogger = log.New(plcLogFile, "[PLC] ", log.LstdFlags|log.Lmicroseconds)

	// CRITICAL LOG
	criticalLogFile, err = os.OpenFile(fmt.Sprintf("backend/logs/critical/critical_%s.log", dateStr),
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Erro critical log: %v", err)
	}
	criticalLogger = log.New(criticalLogFile, "[CRITICAL] ", log.LstdFlags|log.Lmicroseconds)

	// ERROR LOG
	errorLogFile, err = os.OpenFile(fmt.Sprintf("backend/logs/error/error_%s.log", dateStr),
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Erro error log: %v", err)
	}
	errorLogger = log.New(errorLogFile, "[ERROR] ", log.LstdFlags|log.Lmicroseconds)

	// NETWORK LOG
	networkLogFile, err = os.OpenFile(fmt.Sprintf("backend/logs/network/network_%s.log", dateStr),
		os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Erro network log: %v", err)
	}
	networkLogger = log.New(networkLogFile, "[NETWORK] ", log.LstdFlags|log.Lmicroseconds)

	fmt.Printf("üìù Logs v3.1 THREAD-SAFE com ROTATION criados:\n")
	fmt.Printf("   üìä Sistema:   backend/logs/system/system_%s.log\n", dateStr)
	fmt.Printf("   üì° Radar:    backend/logs/radar/radar_%s.log\n", dateStr)
	fmt.Printf("   üéõÔ∏è  PLC:      backend/logs/plc/plc_%s.log\n", dateStr)
	fmt.Printf("   üö® Critical: backend/logs/critical/critical_%s.log\n", dateStr)
	fmt.Printf("   ‚ùå Error:    backend/logs/error/error_%s.log\n", dateStr)
	fmt.Printf("   üåê Network:  backend/logs/network/network_%s.log\n", dateStr)
	fmt.Printf("   üîÑ Rotation: %d dias, %dMB max por arquivo\n", MAX_LOG_FILES, MAX_LOG_SIZE)

	// Log inicial M√çNIMO
	systemLogger.Println("========== LOGS v3.1 THREAD-SAFE COM TIMEOUT INTELIGENTE ==========")
	radarLogger.Println("========== MUDAN√áAS DE ESTADO DOS RADARES v3.1 ==========")
	plcLogger.Println("========== EVENTOS DO PLC v3.1 ==========")
	criticalLogger.Println("========== ALARMES CR√çTICOS v3.1 ==========")
	errorLogger.Println("========== FALHAS DO SISTEMA v3.1 ==========")
	networkLogger.Println("========== PROBLEMAS DE REDE v3.1 ==========")
}

// Flush de todos os logs
func flushAllLogs() {
	if systemLogFile != nil {
		systemLogFile.Sync()
	}
	if radarLogFile != nil {
		radarLogFile.Sync()
	}
	if plcLogFile != nil {
		plcLogFile.Sync()
	}
	if criticalLogFile != nil {
		criticalLogFile.Sync()
	}
	if errorLogFile != nil {
		errorLogFile.Sync()
	}
	if networkLogFile != nil {
		networkLogFile.Sync()
	}
}

// Fechar todos os logs
func closeAllLogs() {
	uptime := time.Since(metrics.StartTime)

	// ‚úÖ THREAD-SAFE ACCESS PARA STATS FINAIS
	_, _, totalPackets, _, totalErrors := metrics.GetStats()

	// Log final M√çNIMO
	if systemLogger != nil {
		systemLogger.Printf("SYSTEM_SHUTDOWN: Uptime=%v, Packets=%d, Errors=%d", uptime, totalPackets, totalErrors)
		systemLogger.Println("========== SISTEMA v3.1 THREAD-SAFE ENCERRADO ==========")
	}

	// Fechar arquivos
	if systemLogFile != nil {
		systemLogFile.Close()
	}
	if errorLogFile != nil {
		errorLogFile.Close()
	}
	if radarLogFile != nil {
		radarLogFile.Close()
	}
	if plcLogFile != nil {
		plcLogFile.Close()
	}
	if networkLogFile != nil {
		networkLogFile.Close()
	}
	if criticalLogFile != nil {
		criticalLogFile.Close()
	}
}

func printSystemHeader() {
	fmt.Print("\033[2J\033[H")
	fmt.Println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
	fmt.Println("‚ïë                    SISTEMA RADAR SICK v3.1                  ‚ïë")
	fmt.Println("‚ïë               üõ°Ô∏è THREAD-SAFE + TIMEOUT 45s üõ°Ô∏è               ‚ïë")
	fmt.Println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
	fmt.Printf("‚ïë Usu√°rio: %-15s                    Data: %s ‚ïë\n",
		getCurrentUser(), time.Now().Format("2006-01-02"))
	fmt.Printf("‚ïë Hora: %-18s                 Vers√£o: v3.1.0 ‚ïë\n",
		time.Now().Format("15:04:05"))
	fmt.Printf("‚ïë Corre√ß√µes: Race Conditions ‚úÖ Memory Leaks ‚úÖ Deadlocks ‚úÖ  ‚ïë\n")
	fmt.Println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
	fmt.Println()
}

func addRadarsToManager(radarManager *radar.RadarManager) {
	radars := []radar.RadarConfig{
		{ID: "caldeira", Name: "Radar Caldeira", IP: "192.168.1.84", Port: 2111},
		{ID: "porta_jusante", Name: "Radar Porta Jusante", IP: "192.168.1.85", Port: 2111},
		{ID: "porta_montante", Name: "Radar Porta Montante", IP: "192.168.1.86", Port: 2111},
	}

	// LOG S√ì SE DER ERRO
	for _, config := range radars {
		if err := radarManager.AddRadar(config); err != nil {
			errorLogger.Printf("RADAR_SETUP_ERROR: %s - %v", config.Name, err)
		}
	}
}

func getInitialRadarStates(plcConnected bool, plcController *plc.PLCController) map[string]bool {
	if plcConnected && plcController != nil {
		enables := plcController.GetRadarsEnabled()
		return enables
	}

	// LOG S√ì SE PLC ESTIVER OFFLINE
	if !plcConnected {
		errorLogger.Println("PLC_OFFLINE: Estados de radar indispon√≠veis")
	}

	return map[string]bool{
		"caldeira":       false,
		"porta_jusante":  false,
		"porta_montante": false,
	}
}

func connectEnabledRadars(radarManager *radar.RadarManager, enabledRadars map[string]bool) {
	for id, enabled := range enabledRadars {
		config, _ := radarManager.GetRadarConfig(id)

		if enabled {
			radar, _ := radarManager.GetRadar(id)
			err := radarManager.ConnectRadarWithRetry(radar, 2)
			if err != nil {
				// LOG S√ì FALHAS DE CONEX√ÉO
				errorLogger.Printf("RADAR_INITIAL_CONNECTION_FAILED: %s - %v", config.Name, err)
				networkLogger.Printf("RADAR_STARTUP_FAIL: %s %s:%d", config.Name, config.IP, config.Port)
			}
		}
	}
}

// ‚úÖ setupGracefulShutdown COM CONTEXT
func setupGracefulShutdown() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)

	go func() {
		sig := <-c
		fmt.Printf("\n\nüõë Sinal: %v - Encerrando...\n", sig)
		if systemLogger != nil {
			systemLogger.Printf("GRACEFUL_SHUTDOWN: Sinal %v recebido", sig)
		}

		gracefulShutdown()
		os.Exit(0)
	}()
}

func getCurrentUser() string {
	if user := os.Getenv("USER"); user != "" {
		return user
	}
	if user := os.Getenv("USERNAME"); user != "" {
		return user
	}
	return "danilohenriquesilvalira"
}

func formatDuration(d time.Duration) string {
	hours := int(d.Hours())
	minutes := int(d.Minutes()) % 60
	seconds := int(d.Seconds()) % 60

	if hours > 0 {
		return fmt.Sprintf("%dh %dm %ds", hours, minutes, seconds)
	} else if minutes > 0 {
		return fmt.Sprintf("%dm %ds", minutes, seconds)
	}
	return fmt.Sprintf("%ds", seconds)
}

func isConnectionError(err error) bool {
	if err == nil {
		return false
	}

	errStr := strings.ToLower(err.Error())
	connectionErrors := []string{
		"connection reset", "connection refused", "broken pipe",
		"network unreachable", "no route to host", "i/o timeout",
		"forcibly closed", "use of closed network connection",
	}

	for _, connErr := range connectionErrors {
		if strings.Contains(errStr, connErr) {
			return true
		}
	}

	if netErr, ok := err.(net.Error); ok {
		return netErr.Timeout() || !netErr.Temporary()
	}

	return false
}
