package main

import (
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"runtime"
	"runtime/debug"
	"strings"
	"syscall"
	"time"

	"backend/internal/monitoring"
	"backend/internal/plc"
	"backend/internal/radar"
)

var (
	// ğŸ“ LOGGERS ESPECIALIZADOS COMPLETOS
	systemLogger      *log.Logger
	errorLogger       *log.Logger
	radarLogger       *log.Logger
	plcLogger         *log.Logger
	criticalLogger    *log.Logger
	performanceLogger *log.Logger
	connectionLogger  *log.Logger

	// ğŸ“ ARQUIVOS DE LOG ESPECIALIZADOS
	systemLogFile      *os.File
	criticalLogFile    *os.File
	performanceLogFile *os.File

	// ğŸ›¡ï¸ HEALTH MONITOR GLOBAL
	healthMonitor *monitoring.HealthMonitor
)

// ğŸ“Š MÃ‰TRICAS EXPANDIDAS DO SISTEMA
type SystemMetrics struct {
	StartTime          time.Time
	PLCConnections     int64
	PLCDisconnections  int64
	PLCReconnections   int64
	RadarReconnections map[string]int64
	TotalPackets       int64
	TotalErrors        int64
	CriticalAlerts     int64
	LastUpdate         time.Time

	// ğŸ†• PERFORMANCE METRICS
	AvgProcessingTime time.Duration
	MaxProcessingTime time.Duration
	TotalOperations   int64
	GoroutinesPeak    int
	MemoryPeakMB      float64

	// ğŸ†• RADAR SPECIFIC METRICS
	RadarDataReceived map[string]int64
	RadarErrors       map[string]int64
	LastRadarData     map[string]time.Time
}

var metrics *SystemMetrics

func main() {
	// ğŸ›¡ï¸ PANIC RECOVERY GLOBAL
	defer func() {
		if r := recover(); r != nil {
			// Stack trace completo
			stack := debug.Stack()

			if criticalLogger != nil {
				criticalLogger.Printf("ğŸ”¥ PANIC CRÃTICO RECUPERADO: %v", r)
				criticalLogger.Printf("ğŸ”¥ STACK TRACE COMPLETO:\n%s", string(stack))
			}

			fmt.Printf("ğŸ”¥ SISTEMA CRASHED - PANIC RECUPERADO: %v\n", r)
			fmt.Printf("ğŸ”¥ Stack trace salvo nos logs crÃ­ticos\n")

			// Cleanup antes de sair
			if healthMonitor != nil {
				healthMonitor.Stop()
			}
			closeAllLogging()

			os.Exit(1)
		}
	}()

	// ğŸ›¡ï¸ INTERCEPTAÃ‡ÃƒO DE SINAIS
	setupAdvancedGracefulShutdown()

	// ğŸ“ INICIALIZAR SISTEMA DE LOGS ROBUSTO
	initAdvancedLogging()
	defer closeAllLogging()

	// ğŸ“Š INICIALIZAR MÃ‰TRICAS EXPANDIDAS
	initExpandedMetrics()

	// ğŸ›¡ï¸ INICIALIZAR HEALTH MONITOR CRÃTICO
	healthMonitor = monitoring.NewHealthMonitor(systemLogger, criticalLogger, performanceLogger)
	healthMonitor.Start()
	defer healthMonitor.Stop()

	// ğŸ¨ HEADER AVANÃ‡ADO DO SISTEMA
	printAdvancedSystemHeader()

	// ğŸ“ LOG INICIAL COMPLETO
	logSystemStartup()

	// ğŸ“¡ CRIAR GERENCIADOR DE RADARES
	radarManager := radar.NewRadarManager()
	addRadarsToManager(radarManager)

	// ğŸ”Œ VARIÃVEIS DE CONTROLE PLC
	var plcSiemens *plc.SiemensPLC
	var plcController *plc.PLCController
	plcConnected := false
	lastPLCAttempt := time.Time{}
	consecutivePLCErrors := 0

	// ğŸ”„ FUNÃ‡ÃƒO DE RECONEXÃƒO PLC ROBUSTA COM HEALTH MONITORING
	tryReconnectPLC := func() bool {
		startTime := time.Now()
		now := time.Now()

		// âœ… VERIFICAR SE JÃ ESTÃ CONECTADO
		if plcConnected && plcSiemens != nil && plcSiemens.IsConnected() {
			healthMonitor.UpdatePLCResponse()
			return true
		}

		// â° RATE LIMITING
		if now.Sub(lastPLCAttempt) < 8*time.Second {
			return false
		}

		lastPLCAttempt = now
		connectionLogger.Printf("ğŸ”„ Tentando reconectar PLC Siemens 192.168.1.33...")

		// ğŸ§¹ CLEANUP COMPLETO DAS CONEXÃ•ES ANTIGAS
		if plcController != nil {
			plcController.Stop()
			time.Sleep(500 * time.Millisecond) // Aguardar goroutines pararem
			plcController = nil
		}

		if plcSiemens != nil && plcSiemens.IsConnected() {
			plcSiemens.Disconnect()
			metrics.PLCDisconnections++
		}

		// ğŸ†• NOVA CONEXÃƒO COM TIMEOUT
		plcSiemens = plc.NewSiemensPLC("192.168.1.33")
		err := plcSiemens.Connect()
		if err != nil {
			consecutivePLCErrors++
			errorLogger.Printf("âŒ PLC: Erro na conexÃ£o (tentativa %d): %v", consecutivePLCErrors, err)
			plcConnected = false

			// ğŸš¨ ALERTA CRÃTICO APÃ“S MUITOS ERROS
			if consecutivePLCErrors >= 5 {
				criticalLogger.Printf("ğŸ”¥ PLC: %d falhas consecutivas de conexÃ£o - PROBLEMA CRÃTICO", consecutivePLCErrors)
			}
			return false
		}

		// âœ… VERIFICAR SE CONEXÃƒO ESTÃ REALMENTE ATIVA
		if !plcSiemens.IsConnected() {
			consecutivePLCErrors++
			errorLogger.Printf("âŒ PLC: ConexÃ£o nÃ£o confirmada (tentativa %d)", consecutivePLCErrors)
			plcConnected = false
			return false
		}

		// ğŸ›ï¸ CRIAR CONTROLADOR PLC
		plcController = plc.NewPLCController(plcSiemens.Client)
		go plcController.Start()
		time.Sleep(2 * time.Second) // Aguardar inicializaÃ§Ã£o

		// âœ… SUCESSO NA CONEXÃƒO
		consecutivePLCErrors = 0
		plcConnected = true
		metrics.PLCConnections++
		metrics.PLCReconnections++

		// ğŸ›¡ï¸ ATUALIZAR HEALTH MONITOR
		healthMonitor.UpdatePLCResponse()
		healthMonitor.UpdatePLCReconnection()

		// ğŸ“Š LOG DE PERFORMANCE
		connectionTime := time.Since(startTime)
		performanceLogger.Printf("PLC_CONNECT_SUCCESS: ConexÃ£o estabelecida em %v (ReconexÃ£o #%d)",
			connectionTime, metrics.PLCReconnections)
		plcLogger.Printf("âœ… PLC CONECTADO com sucesso! (ReconexÃ£o #%d)", metrics.PLCReconnections)

		return true
	}

	// ğŸ”Œ PRIMEIRA CONEXÃƒO
	systemLogger.Println("ğŸ”Œ Iniciando conexÃ£o com PLC Siemens 192.168.1.33...")
	tryReconnectPLC()
	time.Sleep(3 * time.Second)

	// ğŸ“¡ CONECTAR RADARES BASEADO NO ESTADO DO PLC
	enabledRadars := getInitialRadarStates(plcConnected, plcController)
	connectEnabledRadars(radarManager, enabledRadars)

	systemLogger.Println("ğŸš€ Sistema iniciado - Loop principal ativo")
	criticalLogger.Println("ğŸ›¡ï¸ Sistema RADAR SICK v2.5 - Loop principal iniciado")

	// ğŸ”„ LOOP PRINCIPAL OTIMIZADO COM MONITORAMENTO CRÃTICO
	lastReconnectCheck := time.Now()
	lastMetricsUpdate := time.Now()
	lastDisplayUpdate := time.Now()
	lastHealthCheck := time.Now()

	for {
		loopStartTime := time.Now()

		// ğŸ“Š ATUALIZAR TIMESTAMP GLOBAL
		metrics.LastUpdate = time.Now()

		// ğŸ›¡ï¸ HEALTH CHECK CRÃTICO A CADA 30 SEGUNDOS
		if time.Since(lastHealthCheck) >= 30*time.Second {
			systemHealth := healthMonitor.GetSystemHealth()
			if !systemHealth.IsHealthy {
				criticalLogger.Printf("ğŸš¨ SISTEMA EM ESTADO CRÃTICO - Goroutines:%d Memory:%.1fMB",
					systemHealth.Goroutines, systemHealth.MemoryMB)
			}
			lastHealthCheck = time.Now()
		}

		// ğŸ”Œ RECONECTAR PLC COM MONITORING
		plcReconnectStart := time.Now()
		plcConnected = tryReconnectPLC()
		plcReconnectTime := time.Since(plcReconnectStart)

		// ğŸ“Š LOG PERFORMANCE SE RECONEXÃƒO DEMOROU
		if plcReconnectTime > 1*time.Second {
			performanceLogger.Printf("PLC_RECONNECT_SLOW: %v", plcReconnectTime)
		}

		// ğŸ›ï¸ ESTADOS ATUAIS DO SISTEMA
		collectionActive := true
		var currentEnabledRadars map[string]bool

		if plcConnected && plcController != nil {
			collectionActive = plcController.IsCollectionActive()
			currentEnabledRadars = plcController.GetRadarsEnabled()

			// ğŸš¨ VERIFICAR PARADA DE EMERGÃŠNCIA
			if plcController.IsEmergencyStop() {
				criticalLogger.Println("ğŸš¨ PARADA DE EMERGÃŠNCIA ATIVADA VIA PLC - SISTEMA PAUSADO")
				errorLogger.Println("ğŸš¨ PARADA DE EMERGÃŠNCIA ATIVADA VIA PLC")
				time.Sleep(2 * time.Second)
				continue
			}

			// ğŸ”„ RECONEXÃƒO CONTROLADA DOS RADARES
			if time.Since(lastReconnectCheck) >= 8*time.Second {
				radarReconnectStart := time.Now()
				radarManager.CheckAndReconnectEnabled(currentEnabledRadars)
				radarReconnectTime := time.Since(radarReconnectStart)

				// ğŸ“Š LOG SE RECONEXÃƒO DE RADARES DEMOROU
				if radarReconnectTime > 2*time.Second {
					performanceLogger.Printf("RADAR_RECONNECT_SLOW: %v", radarReconnectTime)
				}

				lastReconnectCheck = time.Now()
			}
		} else {
			// PLC desconectado - desabilitar todos os radares
			currentEnabledRadars = map[string]bool{
				"caldeira":       false,
				"porta_jusante":  false,
				"porta_montante": false,
			}
		}

		// â¸ï¸ PAUSAR SE COLETA INATIVA
		if !collectionActive {
			time.Sleep(500 * time.Millisecond)
			continue
		}

		// ğŸ“¡ COLETAR DADOS DOS RADARES COM PERFORMANCE MONITORING
		dataCollectionStart := time.Now()
		multiRadarData := radarManager.CollectEnabledRadarsData(currentEnabledRadars)
		dataCollectionTime := time.Since(dataCollectionStart)

		// ğŸ“Š ATUALIZAR MÃ‰TRICAS DE PERFORMANCE
		metrics.TotalPackets++
		metrics.TotalOperations++

		// Atualizar tempo de processamento
		if dataCollectionTime > metrics.MaxProcessingTime {
			metrics.MaxProcessingTime = dataCollectionTime
		}

		if metrics.AvgProcessingTime == 0 {
			metrics.AvgProcessingTime = dataCollectionTime
		} else {
			metrics.AvgProcessingTime = (metrics.AvgProcessingTime + dataCollectionTime) / 2
		}

		// ğŸ›¡ï¸ ATUALIZAR HEALTH MONITOR
		healthMonitor.UpdateRadarData()
		healthMonitor.UpdateOperationTime(dataCollectionTime)

		// ğŸ“Š LOG SE COLETA DEMOROU
		if dataCollectionTime > 500*time.Millisecond {
			performanceLogger.Printf("DATA_COLLECTION_SLOW: %v para %d radares",
				dataCollectionTime, len(multiRadarData.Radars))
		}

		// ğŸ”Œ ATUALIZAR PLC COM DADOS DOS RADARES
		if plcConnected && plcController != nil {
			writeStartTime := time.Now()
			connectionStatus := radarManager.GetConnectionStatus()

			// Escrever dados no PLC
			err := plcController.WriteMultiRadarData(multiRadarData)
			writeTime := time.Since(writeStartTime)

			if err != nil {
				metrics.TotalErrors++

				if isConnectionError(err) {
					connectionLogger.Printf("ğŸ”Œ ConexÃ£o PLC perdida durante escrita - reconectando...")
					plcConnected = false
					metrics.PLCDisconnections++
					criticalLogger.Printf("ğŸ”Œ PLC: ConexÃ£o perdida durante escrita: %v", err)
				} else {
					errorLogger.Printf("âŒ Erro ao escrever DB100: %v", err)
				}
			} else {
				// ğŸ“Š LOG DE PERFORMANCE DE ESCRITA
				if writeTime > 100*time.Millisecond {
					performanceLogger.Printf("PLC_WRITE_SLOW: %v para %d bytes de dados",
						writeTime, len(multiRadarData.Radars))
				}
			}

			// Atualizar status de conexÃ£o dos radares
			plcController.SetRadarsConnected(connectionStatus)
		}

		// ğŸ¨ EXIBIR STATUS CRÃTICO NO TERMINAL
		if time.Since(lastDisplayUpdate) >= 2*time.Second {
			displayAdvancedSystemStatus(plcConnected, currentEnabledRadars, radarManager)
			lastDisplayUpdate = time.Now()
		}

		// ğŸ“Š LOG DE MÃ‰TRICAS DETALHADAS
		if time.Since(lastMetricsUpdate) >= 15*time.Second {
			logDetailedSystemMetrics()
			lastMetricsUpdate = time.Now()
		}

		// ğŸ“Š MONITORAR PERFORMANCE DO LOOP PRINCIPAL
		loopTime := time.Since(loopStartTime)
		if loopTime > 800*time.Millisecond {
			performanceLogger.Printf("MAIN_LOOP_SLOW: %v - possÃ­vel gargalo detectado", loopTime)
		}

		// â° CONTROLE DE RATE LIMITING
		time.Sleep(1 * time.Second)
	}
}

// ğŸ“ SISTEMA DE LOGGING AVANÃ‡ADO E ROBUSTO
func initAdvancedLogging() {
	// ğŸ“ CRIAR ESTRUTURA DE DIRETÃ“RIOS
	createAdvancedLogDirectories()

	// ğŸ“… NOMES DOS ARQUIVOS COM DATA E HORA
	now := time.Now()
	dateStr := now.Format("2006-01-02")
	timeStr := now.Format("15-04-05")

	// ğŸ—‚ï¸ ARQUIVO PRINCIPAL DO SISTEMA
	systemLogFile = createLogFile(fmt.Sprintf("logs/system/radar_system_%s.log", dateStr))

	// ğŸš¨ ARQUIVO DE ALERTAS CRÃTICOS
	criticalLogFile = createLogFile(fmt.Sprintf("logs/critical/critical_alerts_%s_%s.log", dateStr, timeStr))

	// ğŸ“Š ARQUIVO DE PERFORMANCE
	performanceLogFile = createLogFile(fmt.Sprintf("logs/performance/performance_%s.log", dateStr))

	// ğŸ”§ CONFIGURAR LOGGERS ESPECIALIZADOS
	systemLogger = log.New(systemLogFile, "[SYSTEM] ", log.LstdFlags|log.Lmicroseconds)
	errorLogger = log.New(systemLogFile, "[ERROR]  ", log.LstdFlags|log.Lmicroseconds)
	radarLogger = log.New(systemLogFile, "[RADAR]  ", log.LstdFlags|log.Lmicroseconds)
	plcLogger = log.New(systemLogFile, "[PLC]    ", log.LstdFlags|log.Lmicroseconds)
	connectionLogger = log.New(systemLogFile, "[CONN]   ", log.LstdFlags|log.Lmicroseconds)

	// ğŸš¨ LOGGER CRÃTICO (arquivo separado + console)
	criticalLogger = log.New(criticalLogFile, "[CRITICAL] ", log.LstdFlags|log.Lmicroseconds)

	// ğŸ“Š LOGGER DE PERFORMANCE (arquivo separado)
	performanceLogger = log.New(performanceLogFile, "[PERF] ", log.LstdFlags|log.Lmicroseconds)

	// ğŸ“ INFORMAÃ‡Ã•ES DOS LOGS
	fmt.Printf("ğŸ“ Sistema de logs ROBUSTO ativo:\n")
	fmt.Printf("   ğŸ“‹ Sistema: logs/system/radar_system_%s.log\n", dateStr)
	fmt.Printf("   ğŸš¨ CrÃ­ticos: logs/critical/critical_alerts_%s_%s.log\n", dateStr, timeStr)
	fmt.Printf("   ğŸ“Š Performance: logs/performance/performance_%s.log\n", dateStr)
	fmt.Printf("   ğŸ“ Total de 3 arquivos especializados criados\n")
}

func createAdvancedLogDirectories() {
	dirs := []string{
		"logs",
		"logs/system",
		"logs/critical",
		"logs/performance",
		"logs/radar",
		"logs/plc",
		"logs/archive",
	}

	for _, dir := range dirs {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			if err := os.MkdirAll(dir, 0755); err != nil {
				log.Fatalf("âŒ Erro ao criar diretÃ³rio %s: %v", dir, err)
			}
		}
	}
}

func createLogFile(filename string) *os.File {
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("âŒ Erro ao criar arquivo de log %s: %v", filename, err)
	}
	return file
}

// ğŸ“ LOG INICIAL COMPLETO DO SISTEMA
func logSystemStartup() {
	systemLogger.Println("========== RADAR SICK v2.5 INICIADO ==========")
	systemLogger.Printf("ğŸ‘¤ UsuÃ¡rio: %s", getCurrentUser())
	systemLogger.Printf("ğŸ’» Sistema: %s %s", runtime.GOOS, runtime.GOARCH)
	systemLogger.Printf("ğŸ¹ Go Version: %s", runtime.Version())
	systemLogger.Printf("ğŸ–¥ï¸ CPUs: %d", runtime.NumCPU())
	systemLogger.Printf("ğŸ“… Data/Hora: %s", time.Now().Format("2006-01-02 15:04:05"))
	systemLogger.Printf("ğŸ  DiretÃ³rio: %s", getCurrentDirectory())
	systemLogger.Printf("ğŸ”§ PID: %d", os.Getpid())

	criticalLogger.Printf("ğŸ›¡ï¸ SISTEMA RADAR SICK v2.5 INICIADO - MONITORAMENTO CRÃTICO ATIVO")
	performanceLogger.Printf("ğŸ“Š PERFORMANCE MONITORING INICIADO - PID:%d CPUs:%d", os.Getpid(), runtime.NumCPU())
}

// ğŸ¨ DISPLAY AVANÃ‡ADO COM SAÃšDE CRÃTICA EM TEMPO REAL
func displayAdvancedSystemStatus(plcConnected bool, enabledRadars map[string]bool, radarManager *radar.RadarManager) {
	// ğŸ›¡ï¸ OBTER SAÃšDE COMPLETA DO SISTEMA
	health := healthMonitor.GetSystemHealth()

	// ğŸ§¹ LIMPAR ÃREA DE STATUS (mantÃ©m header)
	fmt.Print("\033[10H\033[J")

	// ğŸ›¡ï¸ STATUS DE SAÃšDE CRÃTICA COM INDICADORES VISUAIS
	healthStatus := "ğŸŸ¢ SAUDÃVEL"
	healthDetails := ""

	if !health.IsHealthy {
		healthStatus = "ğŸ”´ CRÃTICO"
		healthDetails = " - ATENÃ‡ÃƒO REQUERIDA!"
	}

	fmt.Printf("ğŸ›¡ï¸  SAÃšDE DO SISTEMA: %s%s\n", healthStatus, healthDetails)

	// ğŸ“Š MÃ‰TRICAS CRÃTICAS EM TEMPO REAL COM BARRAS
	goroutineBar := createProgressBar(health.Goroutines, 25, 10)
	memoryBar := createProgressBar(int(health.MemoryMB), 200, 10)
	cpuBar := createProgressBar(int(health.CPUPercent), 100, 10)

	fmt.Printf("ğŸ”¥ Goroutines: %2d/25  %s\n", health.Goroutines, goroutineBar)
	fmt.Printf("ğŸ’¾ MemÃ³ria:    %3.0f/200MB %s\n", health.MemoryMB, memoryBar)
	fmt.Printf("ğŸ–¥ï¸ CPU:       %3.0f%%     %s\n", health.CPUPercent, cpuBar)

	// ğŸŒ CONEXÃ•ES TCP DETALHADAS
	tcpInfo := ""
	totalTCP := 0
	for conn, count := range health.TCPConnections {
		totalTCP += count
		if count > 0 {
			tcpInfo += fmt.Sprintf("%s:%d ", conn, count)
		}
	}
	fmt.Printf("ğŸŒ TCP: %d total (%s)\n", totalTCP, strings.TrimSpace(tcpInfo))

	// ğŸ”Œ STATUS PLC COM TEMPO DE RESPOSTA
	plcStatus := "ğŸ”´ DESCONECTADO"
	plcAge := ""
	if plcConnected {
		plcStatus = "ğŸŸ¢ CONECTADO"
		age := time.Since(health.LastPLCResponse)
		if age < 30*time.Second {
			plcAge = fmt.Sprintf("(hÃ¡ %v)", age.Truncate(time.Second))
		} else {
			plcAge = fmt.Sprintf("(âš ï¸ hÃ¡ %v)", age.Truncate(time.Second))
		}
	}
	fmt.Printf("ğŸ›ï¸  PLC Siemens:     %s %s\n", plcStatus, plcAge)

	// ğŸ“¡ STATUS DOS RADARES COM RECONEXÃ•ES
	fmt.Println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
	connectionStatus := radarManager.GetConnectionStatus()
	connectedCount := 0
	enabledCount := 0

	radarConfigs := []struct{ id, name string }{
		{"caldeira", "Radar Caldeira"},
		{"porta_jusante", "Radar Porta Jusante"},
		{"porta_montante", "Radar Porta Montante"},
	}

	for _, config := range radarConfigs {
		isEnabled := enabledRadars[config.id]
		isConnected := connectionStatus[config.id]

		if isEnabled {
			enabledCount++
		}
		if isConnected && isEnabled {
			connectedCount++
		}

		status := "ğŸ”´ DESCONECTADO"
		if !isEnabled {
			status = "âš« DESABILITADO"
		} else if isConnected {
			status = "ğŸŸ¢ CONECTADO   "
		}

		// ğŸ”„ INFORMAÃ‡Ã•ES DE RECONEXÃƒO
		reconns := health.RadarReconnections[config.id]
		reconnInfo := ""
		if reconns > 0 {
			reconnInfo = fmt.Sprintf(" (R:%d)", reconns)
		}

		// ğŸ“Š DADOS RECEBIDOS
		dataInfo := ""
		if lastData, exists := metrics.LastRadarData[config.id]; exists {
			dataAge := time.Since(lastData)
			if dataAge < 10*time.Second {
				dataInfo = " ğŸ“Š"
			}
		}

		fmt.Printf("â”‚ %-20s %s%s%s                â”‚\n", config.name+":", status, reconnInfo, dataInfo)
	}

	fmt.Println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
	fmt.Printf("ğŸ“Š Resumo: %d/%d habilitados | %d conectados\n", enabledCount, 3, connectedCount)

	// ğŸš¨ ALERTAS CRÃTICOS RECENTES
	if len(health.RecentAlerts) > 0 {
		fmt.Println("\nğŸš¨ ALERTAS CRÃTICOS RECENTES:")
		for i, alert := range health.RecentAlerts {
			if i >= 3 { // Mostrar apenas os 3 mais recentes
				break
			}
			age := time.Since(alert.Timestamp)
			levelIcon := "âš ï¸"
			if alert.Level == "CRITICAL" {
				levelIcon = "ğŸ”¥"
			}
			fmt.Printf("   %s [%s] %s (hÃ¡ %v)\n",
				levelIcon, alert.Category, alert.Message, age.Truncate(time.Second))
		}
	}

	// ğŸ“Š MÃ‰TRICAS EXPANDIDAS DO SISTEMA
	uptime := time.Since(metrics.StartTime)
	fmt.Println("\nğŸ“ˆ MÃ‰TRICAS DETALHADAS:")
	fmt.Printf("   â±ï¸  Tempo ativo:       %s\n", formatDuration(uptime))
	fmt.Printf("   ğŸ”Œ PLC:               %d conexÃµes | %d reconexÃµes\n",
		metrics.PLCConnections, metrics.PLCReconnections)
	fmt.Printf("   ğŸ“¦ Dados:             %d pacotes processados\n", metrics.TotalPackets)
	fmt.Printf("   âŒ Problemas:         %d erros | %d alertas crÃ­ticos\n",
		metrics.TotalErrors, health.TotalAlerts)
	fmt.Printf("   âš¡ Performance:       %d operaÃ§Ãµes totais\n", metrics.TotalOperations)
	fmt.Printf("   ğŸ• Processamento:     mÃ©dio %v | mÃ¡ximo %v\n",
		metrics.AvgProcessingTime.Truncate(time.Microsecond),
		metrics.MaxProcessingTime.Truncate(time.Microsecond))
	fmt.Printf("   ğŸ• Ãšltima atualizaÃ§Ã£o: %s\n", metrics.LastUpdate.Format("15:04:05"))

	fmt.Println()
	fmt.Printf("ğŸ“ Logs: system/ | critical/ | performance/\n")
	fmt.Printf("ğŸ›¡ï¸ Health Monitor: %d goroutines | %.1fMB memÃ³ria\n",
		health.Goroutines, health.MemoryMB)
	fmt.Println("ğŸ”„ Sistema RADAR SICK v2.5 em execuÃ§Ã£o... Pressione Ctrl+C para parar.")
}

// ğŸ¨ CRIAR BARRA DE PROGRESSO VISUAL
func createProgressBar(current, max, width int) string {
	if max <= 0 {
		return strings.Repeat("â–‘", width)
	}

	percentage := float64(current) / float64(max)
	if percentage > 1.0 {
		percentage = 1.0
	}

	filled := int(percentage * float64(width))
	bar := ""

	for i := 0; i < width; i++ {
		if i < filled {
			if percentage > 0.8 {
				bar += "â–ˆ" // Vermelho crÃ­tico
			} else if percentage > 0.6 {
				bar += "â–‡" // Amarelo warning
			} else {
				bar += "â–†" // Verde normal
			}
		} else {
			bar += "â–‘"
		}
	}

	return bar
}

// ğŸ“Š LOG DE MÃ‰TRICAS DETALHADAS DO SISTEMA
func logDetailedSystemMetrics() {
	health := healthMonitor.GetSystemHealth()

	// Log de performance detalhado
	performanceLogger.Printf("SYSTEM_METRICS: UP:%v G:%d M:%.1fMB CPU:%.1f%% TCP:%d PLC-R:%d ALERTS:%d OPS:%d AVG:%v MAX:%v",
		health.Uptime.Truncate(time.Second),
		health.Goroutines,
		health.MemoryMB,
		health.CPUPercent,
		getTotalTCPFromHealth(health.TCPConnections),
		health.PLCReconnections,
		health.TotalAlerts,
		metrics.TotalOperations,
		metrics.AvgProcessingTime.Truncate(time.Microsecond),
		metrics.MaxProcessingTime.Truncate(time.Microsecond))

	// Log de saÃºde crÃ­tica se necessÃ¡rio
	if !health.IsHealthy {
		criticalLogger.Printf("SYSTEM_CRITICAL: G:%d M:%.1fMB TCP:%d ALERTS:%d",
			health.Goroutines, health.MemoryMB,
			getTotalTCPFromHealth(health.TCPConnections), health.TotalAlerts)
	}
}

func getTotalTCPFromHealth(connections map[string]int) int {
	total := 0
	for _, count := range connections {
		total += count
	}
	return total
}

// ğŸ“Š INICIALIZAR MÃ‰TRICAS EXPANDIDAS
func initExpandedMetrics() {
	metrics = &SystemMetrics{
		StartTime:          time.Now(),
		PLCConnections:     0,
		PLCDisconnections:  0,
		PLCReconnections:   0,
		RadarReconnections: make(map[string]int64),
		TotalPackets:       0,
		TotalErrors:        0,
		CriticalAlerts:     0,
		LastUpdate:         time.Now(),
		AvgProcessingTime:  0,
		MaxProcessingTime:  0,
		TotalOperations:    0,
		GoroutinesPeak:     0,
		MemoryPeakMB:       0,
		RadarDataReceived:  make(map[string]int64),
		RadarErrors:        make(map[string]int64),
		LastRadarData:      make(map[string]time.Time),
	}

	// Inicializar contadores especÃ­ficos por radar
	radarIDs := []string{"caldeira", "porta_jusante", "porta_montante"}
	for _, id := range radarIDs {
		metrics.RadarReconnections[id] = 0
		metrics.RadarDataReceived[id] = 0
		metrics.RadarErrors[id] = 0
		metrics.LastRadarData[id] = time.Now()
	}
}

// ğŸ¨ HEADER AVANÃ‡ADO DO SISTEMA
func printAdvancedSystemHeader() {
	fmt.Print("\033[2J\033[H") // Limpar tela
	fmt.Println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘                 SISTEMA RADAR SICK v2.5                     â•‘")
	fmt.Println("â•‘              ğŸ›¡ï¸ MONITORAMENTO CRÃTICO ATIVO ğŸ›¡ï¸              â•‘")
	fmt.Println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
	fmt.Printf("â•‘ ğŸ‘¤ UsuÃ¡rio: %-15s         ğŸ“… Data: %s â•‘\n",
		getCurrentUser(), time.Now().Format("2006-01-02"))
	fmt.Printf("â•‘ ğŸ• Hora: %-18s      ğŸ’» Sistema: %-8s â•‘\n",
		time.Now().Format("15:04:05"), runtime.GOOS)
	fmt.Printf("â•‘ ğŸ–¥ï¸ CPUs: %-2d                       ğŸ¹ Go: %-10s â•‘\n",
		runtime.NumCPU(), strings.TrimPrefix(runtime.Version(), "go"))
	fmt.Printf("â•‘ ğŸ”§ PID: %-8d                ğŸ“Š Health Monitor: ON  â•‘\n", os.Getpid())
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Println()
}

// ğŸ§¹ CLEANUP AVANÃ‡ADO DE TODOS OS RECURSOS
func closeAllLogging() {
	if systemLogFile != nil {
		systemLogger.Println("========== SISTEMA RADAR SICK ENCERRADO ==========")
		systemLogger.Printf("Tempo total ativo: %v", time.Since(metrics.StartTime))
		systemLogger.Printf("Total de operaÃ§Ãµes: %d", metrics.TotalOperations)
		systemLogger.Printf("Total de erros: %d", metrics.TotalErrors)
		systemLogFile.Close()
	}

	if criticalLogFile != nil {
		criticalLogger.Println("ğŸ›¡ï¸ SISTEMA DE MONITORAMENTO CRÃTICO FINALIZADO")
		criticalLogger.Printf("Total de alertas crÃ­ticos: %d", metrics.CriticalAlerts)
		criticalLogFile.Close()
	}

	if performanceLogFile != nil {
		performanceLogger.Println("ğŸ“Š LOGS DE PERFORMANCE FINALIZADOS")
		performanceLogger.Printf("Tempo mÃ©dio de operaÃ§Ã£o: %v", metrics.AvgProcessingTime)
		performanceLogger.Printf("Tempo mÃ¡ximo de operaÃ§Ã£o: %v", metrics.MaxProcessingTime)
		performanceLogFile.Close()
	}
}

// ğŸ›¡ï¸ GRACEFUL SHUTDOWN AVANÃ‡ADO E ROBUSTO
func setupAdvancedGracefulShutdown() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)

	go func() {
		sig := <-c
		fmt.Printf("\n\nğŸ›‘ Sinal recebido: %v - Encerrando sistema...\n", sig)

		if criticalLogger != nil {
			criticalLogger.Printf("ğŸ›‘ ENCERRAMENTO SOLICITADO - Sinal: %v", sig)
		}
		if systemLogger != nil {
			systemLogger.Printf("Encerramento gracioso solicitado - Sinal: %v", sig)
		}

		// ğŸ›¡ï¸ PARAR HEALTH MONITOR PRIMEIRO
		if healthMonitor != nil {
			fmt.Println("ğŸ›¡ï¸ Parando health monitor...")
			healthMonitor.Stop()
		}

		// ğŸ§¹ CLEANUP DE LOGS
		fmt.Println("ğŸ“ Finalizando logs...")
		closeAllLogging()

		fmt.Println("âœ… Sistema encerrado com sucesso!")
		os.Exit(0)
	}()
}

// FUNÃ‡Ã•ES AUXILIARES MANTIDAS DO CÃ“DIGO ORIGINAL
func addRadarsToManager(radarManager *radar.RadarManager) {
	radars := []radar.RadarConfig{
		{ID: "caldeira", Name: "Radar Caldeira", IP: "192.168.1.84", Port: 2111},
		{ID: "porta_jusante", Name: "Radar Porta Jusante", IP: "192.168.1.85", Port: 2111},
		{ID: "porta_montante", Name: "Radar Porta Montante", IP: "192.168.1.86", Port: 2111},
	}

	for _, config := range radars {
		if err := radarManager.AddRadar(config); err != nil {
			errorLogger.Printf("âŒ Erro ao adicionar radar %s: %v", config.Name, err)
		} else {
			systemLogger.Printf("âœ… Radar %s adicionado com sucesso", config.Name)
		}
	}
}

func getInitialRadarStates(plcConnected bool, plcController *plc.PLCController) map[string]bool {
	if plcConnected && plcController != nil {
		enables := plcController.GetRadarsEnabled()
		systemLogger.Printf("ğŸ“¡ Estados PLC: Caldeira=%t, Porta Jusante=%t, Porta Montante=%t",
			enables["caldeira"], enables["porta_jusante"], enables["porta_montante"])
		return enables
	}

	systemLogger.Println("ğŸ”´ PLC desconectado - todos radares desabilitados")
	return map[string]bool{
		"caldeira":       false,
		"porta_jusante":  false,
		"porta_montante": false,
	}
}

func connectEnabledRadars(radarManager *radar.RadarManager, enabledRadars map[string]bool) {
	for id, enabled := range enabledRadars {
		config, _ := radarManager.GetRadarConfig(id)

		if enabled {
			radar, _ := radarManager.GetRadar(id)
			radarLogger.Printf("ğŸ”Œ Conectando radar habilitado: %s", config.Name)

			err := radarManager.ConnectRadarWithRetry(radar, 3)
			if err != nil {
				errorLogger.Printf("âŒ Falha ao conectar radar %s: %v", config.Name, err)
			} else {
				radarLogger.Printf("âœ… Radar %s conectado com sucesso", config.Name)
			}
		} else {
			systemLogger.Printf("âš« Radar %s desabilitado - nÃ£o conectando", config.Name)
		}
	}
}

func getCurrentUser() string {
	if user := os.Getenv("USER"); user != "" {
		return user
	}
	if user := os.Getenv("USERNAME"); user != "" {
		return user
	}
	return "unknown"
}

func getCurrentDirectory() string {
	dir, err := os.Getwd()
	if err != nil {
		return "unknown"
	}
	return dir
}

func formatDuration(d time.Duration) string {
	hours := int(d.Hours())
	minutes := int(d.Minutes()) % 60
	seconds := int(d.Seconds()) % 60

	if hours > 0 {
		return fmt.Sprintf("%dh %dm %ds", hours, minutes, seconds)
	} else if minutes > 0 {
		return fmt.Sprintf("%dm %ds", minutes, seconds)
	}
	return fmt.Sprintf("%ds", seconds)
}

func isConnectionError(err error) bool {
	if err == nil {
		return false
	}

	errStr := strings.ToLower(err.Error())
	connectionErrors := []string{
		"connection reset", "connection refused", "broken pipe",
		"network unreachable", "no route to host", "i/o timeout",
		"forcibly closed", "use of closed network connection",
	}

	for _, connErr := range connectionErrors {
		if strings.Contains(errStr, connErr) {
			return true
		}
	}

	if netErr, ok := err.(net.Error); ok {
		return netErr.Timeout() || !netErr.Temporary()
	}

	return false
}
